-- This file was generated by generate.sh in this directory
set search_path = public;
create type public.int4_and_value as (
  arg int4,
  value int8
);

create or replace function arg_min_agg_int4 (a int4_and_value, b int4_and_value)
  returns int4_and_value
  language sql immutable strict parallel safe as
'select case when a.arg is null then b
             when b.arg is null then a
             when a.value <= b.value then a
             else b end';

create or replace function arg_max_agg_int4 (a int4_and_value, b int4_and_value)
  returns int4_and_value
  language sql immutable strict parallel safe as
'select case when a.arg is null then b
             when b.arg is null then a
             when a.value > b.value then a
             else b end';

create function arg_from_int4_and_value(a int4_and_value)
  returns int4
  language sql immutable strict parallel safe as
'select a.arg';

create aggregate arg_min_int4 (int4_and_value) (
  sfunc    = arg_min_agg_int4,
  stype    = int4_and_value,
  finalfunc = arg_from_int4_and_value,
  parallel = safe
);

comment on aggregate arg_min_int4(int4_and_value) is
'For ''select arg_min_int4((arg, value)) from ..'' return the arg for the smallest value';

create aggregate arg_max_int4 (int4_and_value) (
  sfunc    = arg_max_agg_int4,
  stype    = int4_and_value,
  finalfunc = arg_from_int4_and_value,
  parallel = safe
);

comment on aggregate arg_max_int4(int4_and_value) is
'For ''select arg_max_int4((arg, value)) from ..'' return the arg for the largest value';
create type public.int8_and_value as (
  arg int8,
  value int8
);

create or replace function arg_min_agg_int8 (a int8_and_value, b int8_and_value)
  returns int8_and_value
  language sql immutable strict parallel safe as
'select case when a.arg is null then b
             when b.arg is null then a
             when a.value <= b.value then a
             else b end';

create or replace function arg_max_agg_int8 (a int8_and_value, b int8_and_value)
  returns int8_and_value
  language sql immutable strict parallel safe as
'select case when a.arg is null then b
             when b.arg is null then a
             when a.value > b.value then a
             else b end';

create function arg_from_int8_and_value(a int8_and_value)
  returns int8
  language sql immutable strict parallel safe as
'select a.arg';

create aggregate arg_min_int8 (int8_and_value) (
  sfunc    = arg_min_agg_int8,
  stype    = int8_and_value,
  finalfunc = arg_from_int8_and_value,
  parallel = safe
);

comment on aggregate arg_min_int8(int8_and_value) is
'For ''select arg_min_int8((arg, value)) from ..'' return the arg for the smallest value';

create aggregate arg_max_int8 (int8_and_value) (
  sfunc    = arg_max_agg_int8,
  stype    = int8_and_value,
  finalfunc = arg_from_int8_and_value,
  parallel = safe
);

comment on aggregate arg_max_int8(int8_and_value) is
'For ''select arg_max_int8((arg, value)) from ..'' return the arg for the largest value';
create type public.numeric_and_value as (
  arg numeric,
  value int8
);

create or replace function arg_min_agg_numeric (a numeric_and_value, b numeric_and_value)
  returns numeric_and_value
  language sql immutable strict parallel safe as
'select case when a.arg is null then b
             when b.arg is null then a
             when a.value <= b.value then a
             else b end';

create or replace function arg_max_agg_numeric (a numeric_and_value, b numeric_and_value)
  returns numeric_and_value
  language sql immutable strict parallel safe as
'select case when a.arg is null then b
             when b.arg is null then a
             when a.value > b.value then a
             else b end';

create function arg_from_numeric_and_value(a numeric_and_value)
  returns numeric
  language sql immutable strict parallel safe as
'select a.arg';

create aggregate arg_min_numeric (numeric_and_value) (
  sfunc    = arg_min_agg_numeric,
  stype    = numeric_and_value,
  finalfunc = arg_from_numeric_and_value,
  parallel = safe
);

comment on aggregate arg_min_numeric(numeric_and_value) is
'For ''select arg_min_numeric((arg, value)) from ..'' return the arg for the smallest value';

create aggregate arg_max_numeric (numeric_and_value) (
  sfunc    = arg_max_agg_numeric,
  stype    = numeric_and_value,
  finalfunc = arg_from_numeric_and_value,
  parallel = safe
);

comment on aggregate arg_max_numeric(numeric_and_value) is
'For ''select arg_max_numeric((arg, value)) from ..'' return the arg for the largest value';
